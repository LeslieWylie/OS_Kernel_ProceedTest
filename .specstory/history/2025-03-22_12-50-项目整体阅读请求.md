<!-- Generated by SpecStory -->

# é¡¹ç›®æ•´ä½“é˜…è¯»è¯·æ±‚ (2025-03-22 20:50:10)

_**User**_

è¯·ä½ é˜…è¯»æ•´ä¸ªé¡¹ç›®

---

_**Assistant**_



---

<details>
            <summary>Listed current directory â€¢ **14** results</summary>
        
| Name |
|-------|
| ğŸ“ `.specstory` |
| ğŸ“ `kernel` |
| ğŸ“ `include` |
| ğŸ“ `arch` |
| ğŸ“ `boot` |
| ğŸ“ `build` |
| ğŸ“ `drivers` |
| ğŸ“ `file_manager` |
| ğŸ“ `init` |
| ğŸ“ `iso` |
| ğŸ“„ `linker.ld` |
| ğŸ“„ `makefile` |
| ğŸ“„ `PhyOS.iso` |
| ğŸ“„ `README.md` |

</details>

---

æˆ‘å…ˆæ¥çœ‹ä¸€ä¸‹ README.md æ–‡ä»¶ä»¥äº†è§£é¡¹ç›®çš„åŸºæœ¬æƒ…å†µã€‚

---

Read file: README.md

---

ç°åœ¨è®©æˆ‘ç»§ç»­æ£€æŸ¥ä¸€äº›ä¸»è¦ç›®å½•ï¼Œä»¥æ›´æ·±å…¥äº†è§£é¡¹ç›®ç»“æ„ã€‚é¦–å…ˆæŸ¥çœ‹å†…æ ¸æ–‡ä»¶å¤¹ï¼š

---

<details>
            <summary>Listed directory kernel â€¢ **8** results</summary>
        
| Name |
|-------|
| ğŸ“ `process` |
| ğŸ“„ `interrupt.c` |
| ğŸ“„ `kernel.c` |
| ğŸ“„ `printk.c` |
| ğŸ“„ `scheduler.c` |
| ğŸ“„ `shell.c` |
| ğŸ“„ `string.c` |
| ğŸ“„ `syscall.c` |

</details>

---

æˆ‘æ¥çœ‹ä¸€ä¸‹ä¸»è¦çš„å†…æ ¸æ–‡ä»¶ï¼š

---

Read file: kernel/kernel.c

---

<details>
            <summary>Listed directory include â€¢ **10** results</summary>
        
| Name |
|-------|
| ğŸ“„ `scheduler.h` |
| ğŸ“„ `process.h` |
| ğŸ“„ `interrupt.h` |
| ğŸ“„ `io.h` |
| ğŸ“„ `kernel.h` |
| ğŸ“„ `keyboard.h` |
| ğŸ“„ `printk.h` |
| ğŸ“„ `shell.h` |
| ğŸ“„ `string.h` |
| ğŸ“„ `types.h` |

</details>

---

è®©æˆ‘æŸ¥çœ‹å¯åŠ¨ä»£ç å’Œæ¶æ„ç›¸å…³ä»£ç ï¼š

---

<details>
            <summary>Listed directory boot â€¢ **1** results</summary>
        
| Name |
|-------|
| ğŸ“„ `boot.S` |

</details>

---

Read file: boot/boot.S

---

<details>
            <summary>Listed directory arch â€¢ **1** results</summary>
        
| Name |
|-------|
| ğŸ“ `x86` |

</details>

---

<details>
            <summary>Listed directory arch/x86 â€¢ **2** results</summary>
        
| Name |
|-------|
| ğŸ“„ `idt.S` |
| ğŸ“„ `traps.c` |

</details>

---

æˆ‘éœ€è¦çœ‹ä¸€ä¸‹ä¸­æ–­ç›¸å…³çš„æ–‡ä»¶ï¼š

---

Read file: kernel/interrupt.c

---

<details>
            <summary>Listed directory kernel/process â€¢ **1** results</summary>
        
| Name |
|-------|
| ğŸ“„ `process.c` |

</details>

---

Read file: kernel/process/process.c

---

<details>
            <summary>Listed directory drivers â€¢ **1** results</summary>
        
| Name |
|-------|
| ğŸ“„ `keyboard.c` |

</details>

---

Read file: drivers/keyboard.c

---

è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹æ–‡ä»¶ç³»ç»Ÿç›¸å…³çš„ä»£ç ï¼š

---

<details>
            <summary>Listed directory file_manager â€¢ **1** results</summary>
        
| Name |
|-------|
| ğŸ“„ `a.c` |

</details>

---

Read file: kernel/shell.c

---

Read file: makefile

---

ç°åœ¨æˆ‘äº†è§£äº†è¿™ä¸ªæ“ä½œç³»ç»Ÿå†…æ ¸é¡¹ç›®çš„åŸºæœ¬ç»“æ„å’Œç»„ä»¶ã€‚è®©æˆ‘æ€»ç»“ä¸€ä¸‹é¡¹ç›®æƒ…å†µã€‚

è¿™æ˜¯ä¸€ä¸ªåä¸º os_kernelï¼ˆä»README.mdä¸­çœ‹ä¹Ÿå¯èƒ½å«PhyOSï¼‰çš„æ“ä½œç³»ç»Ÿå†…æ ¸é¡¹ç›®ï¼Œä¸»è¦åŒ…å«ä»¥ä¸‹ç»„ä»¶ï¼š

1. **å¯åŠ¨éƒ¨åˆ†**ï¼š
   - `boot/boot.S`ï¼šåŒ…å«ç®€å•çš„å¯åŠ¨ä»£ç ï¼Œè®¾ç½®äº†multibootå¤´éƒ¨å¹¶è°ƒç”¨kernel_mainå‡½æ•°

2. **å†…æ ¸éƒ¨åˆ†**ï¼š
   - `kernel/kernel.c`ï¼šå†…æ ¸çš„ä¸»è¦å…¥å£ç‚¹ï¼Œåˆå§‹åŒ–å„ç§å­ç³»ç»Ÿ
   - `kernel/interrupt.c`ï¼šä¸­æ–­å¤„ç†ç³»ç»Ÿ
   - `kernel/printk.c`ï¼šå†…æ ¸æ‰“å°å‡½æ•°
   - `kernel/shell.c`ï¼šç®€å•çš„å‘½ä»¤è¡Œç•Œé¢
   - `kernel/string.c`ï¼šå­—ç¬¦ä¸²æ“ä½œå‡½æ•°
   - `kernel/process/process.c`ï¼šè¿›ç¨‹ç®¡ç†ç³»ç»Ÿ

3. **æ¶æ„ç›¸å…³**ï¼š
   - `arch/x86/idt.S`ï¼šä¸­æ–­æè¿°ç¬¦è¡¨ç›¸å…³çš„æ±‡ç¼–ä»£ç 
   - `arch/x86/traps.c`ï¼šï¼ˆç›®å‰æ˜¯ç©ºæ–‡ä»¶ï¼‰

4. **è®¾å¤‡é©±åŠ¨**ï¼š
   - `drivers/keyboard.c`ï¼šé”®ç›˜é©±åŠ¨ï¼Œå¤„ç†é”®ç›˜è¾“å…¥

5. **æ–‡ä»¶ç³»ç»Ÿ**ï¼š
   - `file_manager/a.c`ï¼šç›®å‰åªæœ‰ä¸€ä¸ªå ä½æ–‡ä»¶

6. **å¤´æ–‡ä»¶**ï¼š
   - ä½äº`include/`ç›®å½•ï¼ŒåŒ…å«å„ä¸ªæ¨¡å—æ‰€éœ€çš„å£°æ˜å’Œå®šä¹‰

é¡¹ç›®ä½¿ç”¨äº†Makefileè¿›è¡Œæ„å»ºï¼Œç”Ÿæˆå¯å¯åŠ¨çš„ISOé•œåƒï¼Œå¯ä»¥ä½¿ç”¨QEMUè¿›è¡Œæ¨¡æ‹Ÿè¿è¡Œã€‚

è¯¥æ“ä½œç³»ç»Ÿå†…æ ¸æ˜¯ä¸€ä¸ªæ¯”è¾ƒåŸºç¡€çš„å®ç°ï¼Œç›®å‰åŒ…å«äº†ï¼š
- åŸºæœ¬çš„å¯åŠ¨å’Œåˆå§‹åŒ–æµç¨‹
- ä¸­æ–­å¤„ç†ç³»ç»Ÿ
- é”®ç›˜é©±åŠ¨å’Œè¾“å…¥å¤„ç†
- ç®€å•çš„å‘½ä»¤è¡Œç•Œé¢
- è¿›ç¨‹ç®¡ç†çš„åˆæ­¥å®ç°
- å†…å­˜ç®¡ç†ï¼ˆç›®å‰å®ç°ä¸å®Œæ•´ï¼‰

é¡¹ç›®ä¼¼ä¹ä»åœ¨å¼€å‘ä¸­ï¼Œæœ‰äº›æ–‡ä»¶æ˜¯ç©ºçš„ï¼Œä¸€äº›åŠŸèƒ½ï¼ˆå¦‚æ–‡ä»¶ç³»ç»Ÿã€å†…å­˜ç®¡ç†ï¼‰å°šæœªå®Œå…¨å®ç°ã€‚

---

_**User**_

æˆ‘ç°åœ¨æƒ³è¦è®¾è®¡ä¸€ä¸‹å…³äºè¿›ç¨‹çš„æ¨¡å—ï¼Œè¯·ä½ ä¸ç€æ€¥ç›´æ¥å®Œæˆä»£ç ã€‚ä½ å…ˆ
1.è®¾è®¡é¡¹ç›®ç»“æ„
2.æ ¹æ®kernelç›®å½•ä¸‹çš„ä»£ç æ€è€ƒproceedåº”è¯¥æ€æ ·è®¾è®¡
3.æ€è€ƒè®¾è®¡proceedçš„æµç¨‹å¹¶ä¸”å‘Šè¯‰æˆ‘
4.æˆ‘çš„éœ€æ±‚æ˜¯å…·æœ‰proceedåŠŸèƒ½çš„ä»£ç ç‰ˆæœ¬å¯ä»¥å•ç‹¬æµ‹è¯•proceedè¿™ä¸ªæ¨¡å—ï¼Œä»¥æ–¹ä¾¿æˆ‘çŸ¥é“æ˜¯proceedç¼–å†™ä¸­é™¤äº†é—®é¢˜è¿˜æ˜¯æ•´ä¸ªé¡¹ç›®å‡ºé—®é¢˜äº†

---

_**Assistant**_

å¥½çš„ï¼Œè®©æˆ‘ä»¬ä¸€æ­¥æ­¥æ¥è®¾è®¡è¿›ç¨‹æ¨¡å—ã€‚

### 1. é¡¹ç›®ç»“æ„è®¾è®¡

å»ºè®®çš„é¡¹ç›®ç»“æ„å¦‚ä¸‹ï¼š

```
kernel/
â””â”€â”€ process/
    â”œâ”€â”€ process.c          # è¿›ç¨‹ç®¡ç†çš„ä¸»è¦å®ç°
    â”œâ”€â”€ process_test.c     # è¿›ç¨‹ç®¡ç†çš„æµ‹è¯•ä»£ç 
    â”œâ”€â”€ scheduler.c        # è¿›ç¨‹è°ƒåº¦å™¨å®ç°
    â”œâ”€â”€ context.c         # è¿›ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ç›¸å…³
    â””â”€â”€ memory.c          # è¿›ç¨‹å†…å­˜ç®¡ç†ç›¸å…³

include/
â””â”€â”€ kernel/
    â”œâ”€â”€ process.h         # è¿›ç¨‹ç®¡ç†çš„ä¸»è¦å¤´æ–‡ä»¶
    â”œâ”€â”€ scheduler.h       # è°ƒåº¦å™¨ç›¸å…³å®šä¹‰
    â”œâ”€â”€ context.h        # ä¸Šä¸‹æ–‡åˆ‡æ¢ç›¸å…³å®šä¹‰
    â””â”€â”€ memory.h         # å†…å­˜ç®¡ç†ç›¸å…³å®šä¹‰

tests/
â””â”€â”€ process/
    â”œâ”€â”€ test_process.c    # ç‹¬ç«‹çš„è¿›ç¨‹æµ‹è¯•ç¨‹åº
    â”œâ”€â”€ test_scheduler.c  # ç‹¬ç«‹çš„è°ƒåº¦å™¨æµ‹è¯•ç¨‹åº
    â””â”€â”€ Makefile         # æµ‹è¯•ä¸“ç”¨çš„æ„å»ºæ–‡ä»¶
```

### 2. è¿›ç¨‹è®¾è®¡æ€è€ƒ

æ ¹æ®å·²æœ‰çš„`kernel/kernel.c`å’Œ`kernel/process/process.c`ä»£ç ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š

1. **è¿›ç¨‹æ§åˆ¶å— (PCB) è®¾è®¡**ï¼š
```c
typedef struct process {
    pid_t pid;                  // è¿›ç¨‹ID
    process_state_t state;      // è¿›ç¨‹çŠ¶æ€
    uint32_t priority;          // è¿›ç¨‹ä¼˜å…ˆçº§
    void *stack;                // è¿›ç¨‹æ ˆæŒ‡é’ˆ
    size_t stack_size;          // æ ˆå¤§å°
    context_t *context;         // CPUä¸Šä¸‹æ–‡
    mm_struct *mm;              // å†…å­˜ç®¡ç†ç»“æ„
    struct process *parent;     // çˆ¶è¿›ç¨‹
    struct process *next;       // è°ƒåº¦é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªè¿›ç¨‹
    uint64_t creation_time;     // åˆ›å»ºæ—¶é—´
    uint64_t cpu_time;         // CPUä½¿ç”¨æ—¶é—´
    int exit_code;             // é€€å‡ºç 
    char name[32];             // è¿›ç¨‹åç§°
    void *kernel_stack;        // å†…æ ¸æ ˆ
    uint32_t flags;            // è¿›ç¨‹æ ‡å¿—
} process_t;
```

2. **è¿›ç¨‹çŠ¶æ€è®¾è®¡**ï¼š
```c
typedef enum {
    PROCESS_CREATED,    // æ–°åˆ›å»º
    PROCESS_READY,      // å°±ç»ªæ€
    PROCESS_RUNNING,    // è¿è¡Œæ€
    PROCESS_BLOCKED,    // é˜»å¡æ€
    PROCESS_TERMINATED  // ç»ˆæ­¢æ€
} process_state_t;
```

### 3. è¿›ç¨‹æ¨¡å—è®¾è®¡æµç¨‹

1. **åˆå§‹åŒ–é˜¶æ®µ**ï¼š
   - åˆå§‹åŒ–è¿›ç¨‹ç®¡ç†ç³»ç»Ÿ
   - åˆ›å»ºidleè¿›ç¨‹ï¼ˆPID 0ï¼‰
   - åˆå§‹åŒ–è¿›ç¨‹è°ƒåº¦å™¨
   - è®¾ç½®åˆå§‹çš„å†…å­˜ç®¡ç†ç¯å¢ƒ

2. **è¿›ç¨‹åˆ›å»ºæµç¨‹**ï¼š
   ```
   process_create()
   â”œâ”€â”€ åˆ†é…æ–°çš„PID
   â”œâ”€â”€ åˆ†é…è¿›ç¨‹æ§åˆ¶å—
   â”œâ”€â”€ åˆ†é…è¿›ç¨‹å†…æ ¸æ ˆ
   â”œâ”€â”€ åˆå§‹åŒ–è¿›ç¨‹ä¸Šä¸‹æ–‡
   â”œâ”€â”€ è®¾ç½®è¿›ç¨‹åˆå§‹çŠ¶æ€
   â””â”€â”€ åŠ å…¥è°ƒåº¦é˜Ÿåˆ—
   ```

3. **è¿›ç¨‹è°ƒåº¦æµç¨‹**ï¼š
   ```
   schedule()
   â”œâ”€â”€ ä¿å­˜å½“å‰è¿›ç¨‹ä¸Šä¸‹æ–‡
   â”œâ”€â”€ é€‰æ‹©ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„è¿›ç¨‹
   â”œâ”€â”€ æ›´æ–°è¿›ç¨‹çŠ¶æ€
   â””â”€â”€ åˆ‡æ¢åˆ°æ–°è¿›ç¨‹ä¸Šä¸‹æ–‡
   ```

4. **è¿›ç¨‹ç»ˆæ­¢æµç¨‹**ï¼š
   ```
   process_exit()
   â”œâ”€â”€ ä¿å­˜é€€å‡ºç 
   â”œâ”€â”€ é‡Šæ”¾è¿›ç¨‹èµ„æº
   â”œâ”€â”€ é€šçŸ¥çˆ¶è¿›ç¨‹
   â””â”€â”€ è§¦å‘è°ƒåº¦å™¨
   ```

### 4. æ¨¡å—æµ‹è¯•è®¾è®¡

ä¸ºäº†èƒ½å¤Ÿç‹¬ç«‹æµ‹è¯•è¿›ç¨‹æ¨¡å—ï¼Œæˆ‘å»ºè®®ä»¥ä¸‹æ–¹æ¡ˆï¼š

1. **ç‹¬ç«‹æµ‹è¯•ç¯å¢ƒ**ï¼š
```c
// tests/process/test_process.c
#include "test_framework.h"
#include "process.h"

// æ¨¡æ‹Ÿå†…æ ¸ç¯å¢ƒ
static void setup_test_environment() {
    // åˆå§‹åŒ–å¿…è¦çš„å†…æ ¸æ•°æ®ç»“æ„
    // è®¾ç½®æµ‹è¯•ç”¨çš„å†…å­˜ç®¡ç†å‡½æ•°
    // åˆå§‹åŒ–æµ‹è¯•ç”¨çš„æ—¶é’Ÿ
}

// æµ‹è¯•ç”¨ä¾‹
void test_process_create() {
    // æµ‹è¯•è¿›ç¨‹åˆ›å»º
}

void test_process_schedule() {
    // æµ‹è¯•è¿›ç¨‹è°ƒåº¦
}

void test_process_exit() {
    // æµ‹è¯•è¿›ç¨‹é€€å‡º
}

int main() {
    setup_test_environment();
    run_tests();
    return 0;
}
```

2. **æµ‹è¯•ä¸“ç”¨çš„Makefile**ï¼š
```makefile
# tests/process/Makefile
TEST_SRCS = test_process.c ../../kernel/process/process.c
TEST_OBJS = $(TEST_SRCS:.c=.o)
TEST_INCLUDES = -I../../include -I../include

test: $(TEST_OBJS)
    $(CC) $(TEST_OBJS) -o test_process

test_run: test
    ./test_process
```

3. **æ¨¡æ‹Ÿå‡½æ•°**ï¼š
```c
// tests/process/mock_kernel.h
// æ¨¡æ‹Ÿå†…æ ¸å‡½æ•°ï¼Œç”¨äºæµ‹è¯•
void *mock_kmalloc(size_t size);
void mock_kfree(void *ptr);
uint64_t mock_get_time();
void mock_interrupt_disable();
void mock_interrupt_enable();
```

4. **æµ‹è¯•æ¡†æ¶**ï¼š
```c
// tests/include/test_framework.h
#define TEST_ASSERT(condition) \
    do { \
        if (!(condition)) { \
            printf("Test failed: %s\n", #condition); \
            return false; \
        } \
    } while (0)

#define RUN_TEST(test_func) \
    do { \
        printf("Running %s...\n", #test_func); \
        if (test_func()) { \
            printf("PASS\n"); \
        } else { \
            printf("FAIL\n"); \
        } \
    } while (0)
```

è¿™æ ·çš„è®¾è®¡å…è®¸æˆ‘ä»¬ï¼š
1. ç‹¬ç«‹æµ‹è¯•è¿›ç¨‹æ¨¡å—çš„å„ä¸ªåŠŸèƒ½
2. æ¨¡æ‹Ÿå†…æ ¸ç¯å¢ƒï¼Œä¸ä¾èµ–äºå®é™…çš„ç¡¬ä»¶
3. å¯ä»¥å•ç‹¬ç¼–è¯‘å’Œè¿è¡Œæµ‹è¯•
4. å®¹æ˜“å®šä½é—®é¢˜æ˜¯å‡ºåœ¨è¿›ç¨‹æ¨¡å—è¿˜æ˜¯å…¶ä»–éƒ¨åˆ†

ä½ è§‰å¾—è¿™ä¸ªè®¾è®¡æ–¹æ¡ˆå¦‚ä½•ï¼Ÿæˆ‘ä»¬å¯ä»¥æ ¹æ®ä½ çš„å…·ä½“éœ€æ±‚è¿›è¡Œè°ƒæ•´ã€‚å¦‚æœä½ åŒæ„è¿™ä¸ªæ–¹æ¡ˆï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹é€æ­¥å®ç°å„ä¸ªéƒ¨åˆ†ã€‚

---

_**User**_

kernel/
â””â”€â”€ process/
    â”œâ”€â”€ process.c          # è¿›ç¨‹ç®¡ç†çš„ä¸»è¦å®ç°
    â”œâ”€â”€ process_test.c     # è¿›ç¨‹ç®¡ç†çš„æµ‹è¯•ä»£ç 
    â”œâ”€â”€ scheduler.c        # è¿›ç¨‹è°ƒåº¦å™¨å®ç°
    â”œâ”€â”€ context.c         # è¿›ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ç›¸å…³
    â””â”€â”€ memory.c          # è¿›ç¨‹å†…å­˜ç®¡ç†ç›¸å…³

include/
â””â”€â”€ kernel/
    â”œâ”€â”€ process.h         # è¿›ç¨‹ç®¡ç†çš„ä¸»è¦å¤´æ–‡ä»¶
    â”œâ”€â”€ scheduler.h       # è°ƒåº¦å™¨ç›¸å…³å®šä¹‰
    â”œâ”€â”€ context.h        # ä¸Šä¸‹æ–‡åˆ‡æ¢ç›¸å…³å®šä¹‰
    â””â”€â”€ memory.h         # å†…å­˜ç®¡ç†ç›¸å…³å®šä¹‰

tests/
â””â”€â”€ process/
    â”œâ”€â”€ test_process.c    # ç‹¬ç«‹çš„è¿›ç¨‹æµ‹è¯•ç¨‹åº
    â”œâ”€â”€ test_scheduler.c  # ç‹¬ç«‹çš„è°ƒåº¦å™¨æµ‹è¯•ç¨‹åº
    â””â”€â”€ Makefile         # æµ‹è¯•ä¸“ç”¨çš„æ„å»ºæ–‡ä»¶
----
è¯·ä½ æ¥ç®¡terminalï¼Œå¸®æˆ‘æ ¹æ®ä½ è®¾è®¡å¥½çš„é¡¹ç›®ç»“æ„è¿›è¡Œå®Œå–„

---

_**Assistant**_

å¥½çš„ï¼Œæˆ‘æ¥å¸®ä½ åˆ›å»ºè¿™ä¸ªé¡¹ç›®ç»“æ„ã€‚é¦–å…ˆæˆ‘ä»¬éœ€è¦åˆ›å»ºç›¸åº”çš„ç›®å½•å’Œæ–‡ä»¶ã€‚

---

```bash
mkdir -p kernel/process include/kernel tests/process
```

```
PS E:\os_kernel_1.0\os_kernel-main> mkdir -p kernel/process include/kernel tests/process
PS E:\os_kernel_1.0\os_kernel-main> mkdir -p kernel/process include/kernel tests/process



























mkdir: A positional parameter cannot be found that accepts argument 'include/kernel'.
PS E:\os_kernel_1.0\os_kernel-main>
```

---

çœ‹èµ·æ¥åœ¨Windowsç³»ç»Ÿä¸‹mkdirå‘½ä»¤çš„è¯­æ³•æœ‰æ‰€ä¸åŒï¼Œè®©æˆ‘ä»¬åˆ†åˆ«åˆ›å»ºè¿™äº›ç›®å½•ï¼š

---

```bash
mkdir kernel\process include\kernel tests\process
```

```
PS E:\os_kernel_1.0\os_kernel-main> mkdir kernel\process include\kernel tests\process
mkdir: A positional parameter cannot be found that accepts argument 'include\kernel'.
PS E:\os_kernel_1.0\os_kernel-main>
```

---

è®©æˆ‘ä»¬ä¸€ä¸ªä¸€ä¸ªåˆ›å»ºï¼š

---

```bash
mkdir kernel\process; mkdir include\kernel; mkdir tests\process
```

```
PS E:\os_kernel_1.0\os_kernel-main> mkdir kernel\process; mkdir include\kernel; mkdir tests\process
New-Item: An item with the specified name E:\os_kernel_1.0\os_kernel-main\kernel\process already exists
    Directory: E:\os_kernel_1.0\os_kernel-main\include

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d----           2025/3/22    22:07                kernel

    Directory: E:\os_kernel_1.0\os_kernel-main\tests


PS E:\os_kernel_1.0\os_kernel-main>
```

---

ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºæ‰€éœ€çš„æ–‡ä»¶ã€‚é¦–å…ˆåˆ›å»ºå¤´æ–‡ä»¶ï¼š

---

```diff
- 
+ #ifndef _KERNEL_PROCESS_H
+ #define _KERNEL_PROCESS_H
+ 
+ #include <stdint.h>
+ #include <stddef.h>
+ 
+ // è¿›ç¨‹çŠ¶æ€æšä¸¾
+ typedef enum {
+     PROCESS_CREATED,    // æ–°åˆ›å»º
+     PROCESS_READY,      // å°±ç»ªæ€
+     PROCESS_RUNNING,    // è¿è¡Œæ€
+     PROCESS_BLOCKED,    // é˜»å¡æ€
+     PROCESS_TERMINATED  // ç»ˆæ­¢æ€
+ } process_state_t;
+ 
+ // è¿›ç¨‹IDç±»å‹
+ typedef int32_t pid_t;
+ 
+ // å‰å‘å£°æ˜
+ struct mm_struct;
+ struct context;
+ 
+ // è¿›ç¨‹æ§åˆ¶å—ç»“æ„
+ typedef struct process {
+     pid_t pid;                  // è¿›ç¨‹ID
+     process_state_t state;      // è¿›ç¨‹çŠ¶æ€
+     uint32_t priority;          // è¿›ç¨‹ä¼˜å…ˆçº§
+     void *stack;                // è¿›ç¨‹æ ˆæŒ‡é’ˆ
+     size_t stack_size;          // æ ˆå¤§å°
+     struct context *context;    // CPUä¸Šä¸‹æ–‡
+     struct mm_struct *mm;       // å†…å­˜ç®¡ç†ç»“æ„
+     struct process *parent;     // çˆ¶è¿›ç¨‹
+     struct process *next;       // è°ƒåº¦é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªè¿›ç¨‹
+     uint64_t creation_time;     // åˆ›å»ºæ—¶é—´
+     uint64_t cpu_time;         // CPUä½¿ç”¨æ—¶é—´
+     int exit_code;             // é€€å‡ºç 
+     char name[32];             // è¿›ç¨‹åç§°
+     void *kernel_stack;        // å†…æ ¸æ ˆ
+     uint32_t flags;            // è¿›ç¨‹æ ‡å¿—
+ } process_t;
+ 
+ // è¿›ç¨‹ç®¡ç†å‡½æ•°å£°æ˜
+ void process_init(void);
+ pid_t process_create(void (*entry)(void *), void *arg, uint32_t priority);
+ void process_exit(int exit_code);
+ int process_wait(pid_t pid, int *exit_code);
+ process_t *process_get_current(void);
+ void process_set_current(process_t *proc);
+ void process_set_state(process_t *proc, process_state_t new_state);
+ const char *process_state_to_string(process_state_t state);
+ int process_is_alive(process_t *proc);
+ 
+ #endif // _KERNEL_PROCESS_H 
```

---

æ¥ä¸‹æ¥åˆ›å»ºè°ƒåº¦å™¨å¤´æ–‡ä»¶ï¼š

---

```diff
- 
+ #ifndef _KERNEL_SCHEDULER_H
+ #define _KERNEL_SCHEDULER_H
+ 
+ #include "process.h"
+ 
+ // è°ƒåº¦å™¨åˆå§‹åŒ–
+ void scheduler_init(void);
+ 
+ // æ·»åŠ è¿›ç¨‹åˆ°è°ƒåº¦é˜Ÿåˆ—
+ void scheduler_add(process_t *proc);
+ 
+ // ä»è°ƒåº¦é˜Ÿåˆ—ä¸­ç§»é™¤è¿›ç¨‹
+ void scheduler_remove(process_t *proc);
+ 
+ // è¿›è¡Œè¿›ç¨‹è°ƒåº¦
+ void schedule(void);
+ 
+ // è·å–ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„è¿›ç¨‹
+ process_t *scheduler_next(void);
+ 
+ // æ—¶é—´ç‰‡åˆ°æœŸå¤„ç†
+ void scheduler_tick(void);
+ 
+ // é˜»å¡å½“å‰è¿›ç¨‹
+ void scheduler_block(void);
+ 
+ // å”¤é†’è¿›ç¨‹
+ void scheduler_wake(process_t *proc);
+ 
+ #endif // _KERNEL_SCHEDULER_H 
```

---

åˆ›å»ºä¸Šä¸‹æ–‡åˆ‡æ¢ç›¸å…³çš„å¤´æ–‡ä»¶ï¼š

---

```diff
- 
+ #ifndef _KERNEL_CONTEXT_H
+ #define _KERNEL_CONTEXT_H
+ 
+ #include <stdint.h>
+ 
+ // CPUä¸Šä¸‹æ–‡ç»“æ„
+ typedef struct context {
+     // é€šç”¨å¯„å­˜å™¨
+     uint32_t eax;
+     uint32_t ebx;
+     uint32_t ecx;
+     uint32_t edx;
+     uint32_t esi;
+     uint32_t edi;
+     uint32_t ebp;
+     uint32_t esp;
+     
+     // æ®µå¯„å­˜å™¨
+     uint32_t cs;
+     uint32_t ds;
+     uint32_t es;
+     uint32_t fs;
+     uint32_t gs;
+     uint32_t ss;
+     
+     // ç¨‹åºè®¡æ•°å™¨å’Œæ ‡å¿—å¯„å­˜å™¨
+     uint32_t eip;
+     uint32_t eflags;
+ } context_t;
+ 
+ // ä¸Šä¸‹æ–‡æ“ä½œå‡½æ•°
+ void context_init(context_t *context, void (*entry)(void *), void *arg, void *stack_top);
+ void context_switch(context_t *from, context_t *to);
+ void context_save(context_t *context);
+ void context_restore(context_t *context);
+ 
+ #endif // _KERNEL_CONTEXT_H 
```

---

åˆ›å»ºå†…å­˜ç®¡ç†ç›¸å…³çš„å¤´æ–‡ä»¶ï¼š

---

```diff
- 
+ #ifndef _KERNEL_MEMORY_H
+ #define _KERNEL_MEMORY_H
+ 
+ #include <stdint.h>
+ #include <stddef.h>
+ 
+ // å†…å­˜åŒºåŸŸæè¿°ç¬¦
+ typedef struct vm_area_struct {
+     uint32_t start;             // èµ·å§‹åœ°å€
+     uint32_t end;               // ç»“æŸåœ°å€
+     uint32_t flags;             // æƒé™æ ‡å¿—
+     struct vm_area_struct *next;// é“¾è¡¨ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
+ } vm_area_struct_t;
+ 
+ // å†…å­˜ç®¡ç†ç»“æ„
+ typedef struct mm_struct {
+     vm_area_struct_t *mmap;     // å†…å­˜æ˜ å°„é“¾è¡¨
+     uint32_t start_code;        // ä»£ç æ®µèµ·å§‹
+     uint32_t end_code;          // ä»£ç æ®µç»“æŸ
+     uint32_t start_data;        // æ•°æ®æ®µèµ·å§‹
+     uint32_t end_data;          // æ•°æ®æ®µç»“æŸ
+     uint32_t start_heap;        // å †èµ·å§‹
+     uint32_t end_heap;          // å †ç»“æŸ
+     uint32_t start_stack;       // æ ˆèµ·å§‹
+ } mm_struct_t;
+ 
+ // å†…å­˜ç®¡ç†å‡½æ•°
+ void *kmalloc(size_t size);
+ void kfree(void *ptr);
+ mm_struct_t *mm_create(void);
+ void mm_destroy(mm_struct_t *mm);
+ void *allocate_kernel_stack(size_t size);
+ void free_kernel_stack(void *stack);
+ 
+ #endif // _KERNEL_MEMORY_H 
```

---

ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºè¿›ç¨‹ç®¡ç†çš„ä¸»è¦å®ç°æ–‡ä»¶ï¼š

---

```diff
- 
- #include <process.h>
- #include <scheduler.h>
- #include <stddef.h>
+ #include "process.h"
+ #include "memory.h"
+ #include "scheduler.h"
+ #include "context.h"
+ #include "printk.h"
  
            // å…¨å±€å˜é‡
            static pid_t next_pid = 1;
  static process_t *current_process = NULL;
+ 
+ // åˆå§‹åŒ–è¿›ç¨‹ç®¡ç†ç³»ç»Ÿ
+ void process_init(void) {
+     // åˆ›å»ºidleè¿›ç¨‹ï¼ˆPID 0ï¼‰
+     process_t *idle = kmalloc(sizeof(process_t));
+     if (!idle) {
+         printk("Failed to create idle process\n");
+         return;
+     }
+ 
+     // åˆå§‹åŒ–idleè¿›ç¨‹
+     idle->pid = 0;
+     idle->state = PROCESS_RUNNING;
+     idle->priority = 0;
+     idle->stack = NULL;
+     idle->stack_size = 0;
+     idle->context = NULL;
+     idle->mm = NULL;
+     idle->parent = NULL;
+     idle->next = NULL;
+     idle->creation_time = 0;
+     idle->cpu_time = 0;
+     idle->exit_code = 0;
+     idle->kernel_stack = NULL;
+     idle->flags = 0;
+ 
+     current_process = idle;
+     scheduler_init();
+ }
  
  // è·å–å½“å‰è¿è¡Œçš„è¿›ç¨‹
  pid_t process_create(void (*entry)(void *), void *arg, uint32_t priority)
  {
-     // åˆ†é…è¿›ç¨‹æ§åˆ¶å— (å®é™…å®ç°ä¸­åº”è¯¥ä½¿ç”¨å†…å­˜åˆ†é…å‡½æ•°)
-     process_t *proc = (process_t *)NULL; // æ›¿æ¢ä¸ºé€‚å½“çš„å†…å­˜åˆ†é…
-     if (!proc)
-     {
-         return -1; // å†…å­˜åˆ†é…å¤±è´¥
+     // åˆ†é…è¿›ç¨‹æ§åˆ¶å—
+     process_t *proc = kmalloc(sizeof(process_t));
+     if (!proc) {
+         return -1;
+     }
+ 
+     // åˆ†é…å†…æ ¸æ ˆ
+     proc->kernel_stack = allocate_kernel_stack(4096); // 4KBå†…æ ¸æ ˆ
+     if (!proc->kernel_stack) {
+         kfree(proc);
+         return -1;
      }
  
      proc->state = PROCESS_CREATED;
      proc->priority = priority;
-     proc->stack = NULL; // æš‚ä¸åˆ†é…æ ˆ
+     proc->stack = NULL;
      proc->stack_size = 0;
-     proc->context = NULL; // æš‚ä¸åˆ›å»ºä¸Šä¸‹æ–‡
-     proc->mm = NULL;      // æš‚ä¸å¤„ç†å†…å­˜æ˜ å°„
-     proc->parent = process_get_current();
+     proc->context = kmalloc(sizeof(context_t));
+     if (!proc->context) {
+         free_kernel_stack(proc->kernel_stack);
+         kfree(proc);
+         return -1;
+     }
+ 
+     // åˆå§‹åŒ–ä¸Šä¸‹æ–‡
+     context_init(proc->context, entry, arg, (char *)proc->kernel_stack + 4096);
+ 
+     proc->mm = mm_create();
+     proc->parent = current_process;
      proc->next = NULL;
-     proc->creation_time = 0; // åº”è¯¥è·å–å½“å‰ç³»ç»Ÿæ—¶é—´
+     proc->creation_time = 0; // TODO: è·å–ç³»ç»Ÿæ—¶é—´
      proc->cpu_time = 0;
      proc->exit_code = 0;
+     proc->flags = 0;
  
      // è®¾ç½®ä¸ºå°±ç»ªçŠ¶æ€
  void process_exit(int exit_code)
  {
-     process_t *current = process_get_current();
-     if (current)
-     {
-         current->exit_code = exit_code;
-         process_set_state(current, PROCESS_TERMINATED);
+     if (!current_process) {
+         return;
+     }
+ 
+     current_process->exit_code = exit_code;
+     process_set_state(current_process, PROCESS_TERMINATED);
+ 
+     // é‡Šæ”¾èµ„æº
+     if (current_process->mm) {
+         mm_destroy(current_process->mm);
+     }
+     if (current_process->context) {
+         kfree(current_process->context);
+     }
+     if (current_process->kernel_stack) {
+         free_kernel_stack(current_process->kernel_stack);
+     }
  
      // ä»è°ƒåº¦å™¨ä¸­ç§»é™¤
-         scheduler_remove(current);
+     scheduler_remove(current_process);
  
      // è§¦å‘è°ƒåº¦
      schedule();
-     }
  }
  
  // ç­‰å¾…æŒ‡å®šè¿›ç¨‹ç»“æŸ
  int process_wait(pid_t pid, int *exit_code)
  {
-     // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–ç‰ˆæœ¬
-     // å®é™…å®ç°éœ€è¦æŸ¥æ‰¾è¿›ç¨‹å¹¶ç­‰å¾…å…¶ç»“æŸ
-     return -1; // æœªå®ç°
+     // TODO: å®ç°è¿›ç¨‹ç­‰å¾…åŠŸèƒ½
+     return -1;
  }
  EOF
```

---

ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºè°ƒåº¦å™¨çš„å®ç°æ–‡ä»¶ï¼š

---

```diff
- 
+ #include "scheduler.h"
+ #include "process.h"
+ #include "context.h"
+ #include "printk.h"
+ 
+ // å°±ç»ªé˜Ÿåˆ—å¤´
+ static process_t *ready_queue = NULL;
+ 
+ // åˆå§‹åŒ–è°ƒåº¦å™¨
+ void scheduler_init(void) {
+     ready_queue = NULL;
+ }
+ 
+ // æ·»åŠ è¿›ç¨‹åˆ°è°ƒåº¦é˜Ÿåˆ—
+ void scheduler_add(process_t *proc) {
+     if (!proc) {
+         return;
+     }
+ 
+     // ç®€å•çš„ä¼˜å…ˆçº§é˜Ÿåˆ—æ’å…¥
+     if (!ready_queue || proc->priority > ready_queue->priority) {
+         proc->next = ready_queue;
+         ready_queue = proc;
+     } else {
+         process_t *current = ready_queue;
+         while (current->next && current->next->priority >= proc->priority) {
+             current = current->next;
+         }
+         proc->next = current->next;
+         current->next = proc;
+     }
+ }
+ 
+ // ä»è°ƒåº¦é˜Ÿåˆ—ä¸­ç§»é™¤è¿›ç¨‹
+ void scheduler_remove(process_t *proc) {
+     if (!proc || !ready_queue) {
+         return;
+     }
+ 
+     if (ready_queue == proc) {
+         ready_queue = ready_queue->next;
+         return;
+     }
+ 
+     process_t *current = ready_queue;
+     while (current->next) {
+         if (current->next == proc) {
+             current->next = proc->next;
+             return;
+         }
+         current = current->next;
+     }
+ }
+ 
+ // è·å–ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„è¿›ç¨‹
+ process_t *scheduler_next(void) {
+     if (!ready_queue) {
+         return process_get_current(); // å¦‚æœæ²¡æœ‰å°±ç»ªè¿›ç¨‹ï¼Œç»§ç»­è¿è¡Œå½“å‰è¿›ç¨‹
+     }
+     return ready_queue;
+ }
+ 
+ // è¿›è¡Œè¿›ç¨‹è°ƒåº¦
+ void schedule(void) {
+     process_t *current = process_get_current();
+     process_t *next = scheduler_next();
+ 
+     if (current == next) {
+         return; // æ— éœ€åˆ‡æ¢
+     }
+ 
+     // ä¿å­˜å½“å‰è¿›ç¨‹ä¸Šä¸‹æ–‡
+     if (current && current->state == PROCESS_RUNNING) {
+         current->state = PROCESS_READY;
+         scheduler_add(current);
+     }
+ 
+     // åˆ‡æ¢åˆ°æ–°è¿›ç¨‹
+     if (next) {
+         next->state = PROCESS_RUNNING;
+         process_set_current(next);
+         scheduler_remove(next);
+ 
+         // åˆ‡æ¢ä¸Šä¸‹æ–‡
+         if (current && current->context) {
+             context_switch(current->context, next->context);
+         } else {
+             context_restore(next->context);
+         }
+     }
+ }
+ 
+ // æ—¶é—´ç‰‡åˆ°æœŸå¤„ç†
+ void scheduler_tick(void) {
+     // ç®€å•çš„æ—¶é—´ç‰‡è½®è½¬
+     schedule();
+ }
+ 
+ // é˜»å¡å½“å‰è¿›ç¨‹
+ void scheduler_block(void) {
+     process_t *current = process_get_current();
+     if (current) {
+         current->state = PROCESS_BLOCKED;
+         schedule(); // è§¦å‘è°ƒåº¦
+     }
+ }
+ 
+ // å”¤é†’è¿›ç¨‹
+ void scheduler_wake(process_t *proc) {
+     if (proc && proc->state == PROCESS_BLOCKED) {
+         proc->state = PROCESS_READY;
+         scheduler_add(proc);
+     }
+ } 
```

---

åˆ›å»ºä¸Šä¸‹æ–‡åˆ‡æ¢çš„å®ç°æ–‡ä»¶ï¼š

---

```diff
- 
+ #include "context.h"
+ #include <string.h>
+ 
+ // åˆå§‹åŒ–ä¸Šä¸‹æ–‡
+ void context_init(context_t *context, void (*entry)(void *), void *arg, void *stack_top) {
+     memset(context, 0, sizeof(context_t));
+     
+     // è®¾ç½®å…¥å£ç‚¹
+     context->eip = (uint32_t)entry;
+     
+     // è®¾ç½®æ ˆæŒ‡é’ˆ
+     context->esp = (uint32_t)stack_top;
+     
+     // è®¾ç½®å‚æ•°
+     context->eax = (uint32_t)arg;
+     
+     // è®¾ç½®æ®µå¯„å­˜å™¨
+     context->cs = 0x08;  // å†…æ ¸ä»£ç æ®µ
+     context->ds = 0x10;  // å†…æ ¸æ•°æ®æ®µ
+     context->es = 0x10;
+     context->fs = 0x10;
+     context->gs = 0x10;
+     context->ss = 0x10;
+     
+     // è®¾ç½®æ ‡å¿—å¯„å­˜å™¨ï¼ˆå¯ç”¨ä¸­æ–­ï¼‰
+     context->eflags = 0x202;  // IF=1, IOPL=0
+ }
+ 
+ // ä¿å­˜å½“å‰ä¸Šä¸‹æ–‡
+ void context_save(context_t *context) {
+     __asm__ volatile (
+         "movl %%eax, %0\n"
+         "movl %%ebx, %1\n"
+         "movl %%ecx, %2\n"
+         "movl %%edx, %3\n"
+         "movl %%esi, %4\n"
+         "movl %%edi, %5\n"
+         "movl %%ebp, %6\n"
+         "movl %%esp, %7\n"
+         : "=m"(context->eax), "=m"(context->ebx),
+           "=m"(context->ecx), "=m"(context->edx),
+           "=m"(context->esi), "=m"(context->edi),
+           "=m"(context->ebp), "=m"(context->esp)
+         :
+         : "memory"
+     );
+ 
+     // ä¿å­˜æ®µå¯„å­˜å™¨
+     __asm__ volatile (
+         "movw %%cs, %0\n"
+         "movw %%ds, %1\n"
+         "movw %%es, %2\n"
+         "movw %%fs, %3\n"
+         "movw %%gs, %4\n"
+         "movw %%ss, %5\n"
+         : "=m"(context->cs), "=m"(context->ds),
+           "=m"(context->es), "=m"(context->fs),
+           "=m"(context->gs), "=m"(context->ss)
+         :
+         : "memory"
+     );
+ 
+     // ä¿å­˜æ ‡å¿—å¯„å­˜å™¨
+     __asm__ volatile (
+         "pushfl\n"
+         "popl %0\n"
+         : "=m"(context->eflags)
+         :
+         : "memory"
+     );
+ }
+ 
+ // æ¢å¤ä¸Šä¸‹æ–‡
+ void context_restore(context_t *context) {
+     // æ¢å¤æ®µå¯„å­˜å™¨
+     __asm__ volatile (
+         "movw %0, %%ds\n"
+         "movw %0, %%es\n"
+         "movw %0, %%fs\n"
+         "movw %0, %%gs\n"
+         :
+         : "r"(context->ds)
+         : "memory"
+     );
+ 
+     // æ¢å¤é€šç”¨å¯„å­˜å™¨å’Œæ ˆ
+     __asm__ volatile (
+         "movl %0, %%eax\n"
+         "movl %1, %%ebx\n"
+         "movl %2, %%ecx\n"
+         "movl %3, %%edx\n"
+         "movl %4, %%esi\n"
+         "movl %5, %%edi\n"
+         "movl %6, %%ebp\n"
+         "movl %7, %%esp\n"
+         :
+         : "m"(context->eax), "m"(context->ebx),
+           "m"(context->ecx), "m"(context->edx),
+           "m"(context->esi), "m"(context->edi),
+           "m"(context->ebp), "m"(context->esp)
+         : "memory"
+     );
+ 
+     // æ¢å¤æ ‡å¿—å¯„å­˜å™¨å¹¶è·³è½¬åˆ°eip
+     __asm__ volatile (
+         "pushl %0\n"      // eflags
+         "popfl\n"
+         "pushl %1\n"      // cs
+         "pushl %2\n"      // eip
+         "iret\n"
+         :
+         : "r"(context->eflags),
+           "r"(context->cs),
+           "r"(context->eip)
+     );
+ }
+ 
+ // åˆ‡æ¢ä¸Šä¸‹æ–‡
+ void context_switch(context_t *from, context_t *to) {
+     context_save(from);
+     context_restore(to);
+ } 
```

---

åˆ›å»ºå†…å­˜ç®¡ç†çš„å®ç°æ–‡ä»¶ï¼š

---

```diff
- 
+ #include "memory.h"
+ #include <string.h>
+ 
+ // ç®€å•çš„å†…å­˜åˆ†é…å™¨å®ç°ï¼ˆä»…ç”¨äºæµ‹è¯•ï¼‰
+ #define HEAP_SIZE (1024 * 1024)  // 1MBå †ç©ºé—´
+ static char heap[HEAP_SIZE];
+ static size_t heap_used = 0;
+ 
+ void *kmalloc(size_t size) {
+     if (heap_used + size > HEAP_SIZE) {
+         return NULL;
+     }
+     
+     void *ptr = &heap[heap_used];
+     heap_used += size;
+     
+     // å¯¹é½åˆ°4å­—èŠ‚è¾¹ç•Œ
+     heap_used = (heap_used + 3) & ~3;
+     
+     return ptr;
+ }
+ 
+ void kfree(void *ptr) {
+     // ç®€å•å®ç°ï¼Œä¸å®é™…é‡Šæ”¾å†…å­˜
+     (void)ptr;
+ }
+ 
+ // åˆ›å»ºå†…å­˜ç®¡ç†ç»“æ„
+ mm_struct_t *mm_create(void) {
+     mm_struct_t *mm = kmalloc(sizeof(mm_struct_t));
+     if (!mm) {
+         return NULL;
+     }
+     
+     memset(mm, 0, sizeof(mm_struct_t));
+     return mm;
+ }
+ 
+ // é”€æ¯å†…å­˜ç®¡ç†ç»“æ„
+ void mm_destroy(mm_struct_t *mm) {
+     if (!mm) {
+         return;
+     }
+     
+     // é‡Šæ”¾æ‰€æœ‰å†…å­˜åŒºåŸŸ
+     vm_area_struct_t *vma = mm->mmap;
+     while (vma) {
+         vm_area_struct_t *next = vma->next;
+         kfree(vma);
+         vma = next;
+     }
+     
+     kfree(mm);
+ }
+ 
+ // åˆ†é…å†…æ ¸æ ˆ
+ void *allocate_kernel_stack(size_t size) {
+     return kmalloc(size);
+ }
+ 
+ // é‡Šæ”¾å†…æ ¸æ ˆ
+ void free_kernel_stack(void *stack) {
+     kfree(stack);
+ } 
```

---

æœ€åï¼Œè®©æˆ‘ä»¬åˆ›å»ºè¿›ç¨‹æµ‹è¯•æ–‡ä»¶ï¼š

---

```diff
- 
+ #include "process.h"
+ #include "scheduler.h"
+ #include "printk.h"
+ #include <string.h>
+ 
+ // æµ‹è¯•è¿›ç¨‹å‡½æ•°
+ static void test_process(void *arg) {
+     const char *name = (const char *)arg;
+     for (int i = 0; i < 3; i++) {
+         printk("Process %s: iteration %d\n", name, i);
+         // æ¨¡æ‹Ÿä¸€äº›å·¥ä½œ
+         for (volatile int j = 0; j < 1000000; j++);
+     }
+ }
+ 
+ // æµ‹è¯•è¿›ç¨‹åˆ›å»ºå’Œè°ƒåº¦
+ void test_process_creation(void) {
+     printk("Starting process creation test...\n");
+ 
+     // åˆå§‹åŒ–è¿›ç¨‹ç³»ç»Ÿ
+     process_init();
+ 
+     // åˆ›å»ºæµ‹è¯•è¿›ç¨‹
+     pid_t pid1 = process_create(test_process, "Process1", 1);
+     pid_t pid2 = process_create(test_process, "Process2", 2);
+     pid_t pid3 = process_create(test_process, "Process3", 1);
+ 
+     printk("Created processes with PIDs: %d, %d, %d\n", pid1, pid2, pid3);
+ 
+     // è¿è¡Œè°ƒåº¦å™¨
+     for (int i = 0; i < 10; i++) {
+         schedule();
+         // æ¨¡æ‹Ÿæ—¶é—´ç‰‡
+         for (volatile int j = 0; j < 1000000; j++);
+     }
+ 
+     printk("Process creation test completed.\n");
+ }
+ 
+ // æµ‹è¯•è¿›ç¨‹çŠ¶æ€è½¬æ¢
+ void test_process_state_transitions(void) {
+     printk("Starting process state transition test...\n");
+ 
+     process_t *current = process_get_current();
+     if (current) {
+         printk("Current process (PID %d) state: %s\n",
+                current->pid,
+                process_state_to_string(current->state));
+ 
+         // æµ‹è¯•çŠ¶æ€è½¬æ¢
+         process_set_state(current, PROCESS_BLOCKED);
+         printk("After blocking - State: %s\n",
+                process_state_to_string(current->state));
+ 
+         scheduler_wake(current);
+         printk("After waking - State: %s\n",
+                process_state_to_string(current->state));
+     }
+ 
+     printk("Process state transition test completed.\n");
+ }
+ 
+ // æµ‹è¯•è¿›ç¨‹ä¼˜å…ˆçº§è°ƒåº¦
+ void test_priority_scheduling(void) {
+     printk("Starting priority scheduling test...\n");
+ 
+     // åˆ›å»ºä¸åŒä¼˜å…ˆçº§çš„è¿›ç¨‹
+     pid_t high_prio = process_create(test_process, "HighPriority", 3);
+     pid_t med_prio = process_create(test_process, "MedPriority", 2);
+     pid_t low_prio = process_create(test_process, "LowPriority", 1);
+ 
+     printk("Created processes - High: %d, Med: %d, Low: %d\n",
+            high_prio, med_prio, low_prio);
+ 
+     // è¿è¡Œè°ƒåº¦å™¨
+     for (int i = 0; i < 10; i++) {
+         schedule();
+         // æ¨¡æ‹Ÿæ—¶é—´ç‰‡
+         for (volatile int j = 0; j < 1000000; j++);
+     }
+ 
+     printk("Priority scheduling test completed.\n");
+ }
+ 
+ // è¿è¡Œæ‰€æœ‰æµ‹è¯•
+ void run_process_tests(void) {
+     printk("=== Starting Process Management Tests ===\n");
+ 
+     test_process_creation();
+     test_process_state_transitions();
+     test_priority_scheduling();
+ 
+     printk("=== All Process Management Tests Completed ===\n");
+ } 
```

---

ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºæµ‹è¯•ä¸“ç”¨çš„Makefileï¼š

---

```diff
- 
+ # ç¼–è¯‘å™¨å’Œæ ‡å¿—
+ CC = gcc
+ CFLAGS = -m32 -Wall -Wextra -I../../include
+ 
+ # æºæ–‡ä»¶
+ TEST_SRCS = test_process.c \
+             ../../kernel/process/process.c \
+             ../../kernel/process/scheduler.c \
+             ../../kernel/process/context.c \
+             ../../kernel/process/memory.c
+ 
+ # ç›®æ ‡æ–‡ä»¶
+ TEST_OBJS = $(TEST_SRCS:.c=.o)
+ 
+ # é»˜è®¤ç›®æ ‡
+ all: test_process
+ 
+ # ç¼–è¯‘æµ‹è¯•ç¨‹åº
+ test_process: $(TEST_OBJS)
+ 	$(CC) $(CFLAGS) -o $@ $^
+ 
+ # ç¼–è¯‘æºæ–‡ä»¶
+ %.o: %.c
+ 	$(CC) $(CFLAGS) -c -o $@ $<
+ 
+ # è¿è¡Œæµ‹è¯•
+ test: test_process
+ 	./test_process
+ 
+ # æ¸…ç†
+ clean:
+ 	rm -f test_process $(TEST_OBJS)
+ 
+ .PHONY: all test clean 
```

---

æœ€åï¼Œè®©æˆ‘ä»¬åˆ›å»ºç‹¬ç«‹çš„æµ‹è¯•ç¨‹åºï¼š

---

```diff
- 
+ #include "process.h"
+ #include "scheduler.h"
+ #include "context.h"
+ #include "memory.h"
+ #include <stdio.h>
+ #include <string.h>
+ 
+ // æ¨¡æ‹Ÿprintkå‡½æ•°
+ void printk(const char *fmt, ...) {
+     va_list args;
+     va_start(args, fmt);
+     vprintf(fmt, args);
+     va_end(args);
+ }
+ 
+ // æµ‹è¯•è¿›ç¨‹å‡½æ•°
+ static void test_process_func(void *arg) {
+     int id = *(int*)arg;
+     printf("Test process %d started\n", id);
+     
+     // æ¨¡æ‹Ÿä¸€äº›å·¥ä½œ
+     for (int i = 0; i < 3; i++) {
+         printf("Process %d: iteration %d\n", id, i);
+     }
+     
+     printf("Test process %d completed\n", id);
+ }
+ 
+ // æµ‹è¯•è¿›ç¨‹åˆ›å»º
+ void test_process_creation() {
+     printf("\n=== Testing Process Creation ===\n");
+     
+     // åˆå§‹åŒ–è¿›ç¨‹ç³»ç»Ÿ
+     process_init();
+     
+     // åˆ›å»ºæµ‹è¯•è¿›ç¨‹
+     int id1 = 1, id2 = 2;
+     pid_t pid1 = process_create(test_process_func, &id1, 1);
+     pid_t pid2 = process_create(test_process_func, &id2, 2);
+     
+     printf("Created processes with PIDs: %d, %d\n", pid1, pid2);
+     
+     if (pid1 > 0 && pid2 > 0) {
+         printf("Process creation test: PASSED\n");
+     } else {
+         printf("Process creation test: FAILED\n");
+     }
+ }
+ 
+ // æµ‹è¯•è¿›ç¨‹çŠ¶æ€è½¬æ¢
+ void test_process_states() {
+     printf("\n=== Testing Process States ===\n");
+     
+     process_t *proc = process_get_current();
+     if (!proc) {
+         printf("No current process found\n");
+         return;
+     }
+     
+     printf("Initial state: %s\n", process_state_to_string(proc->state));
+     
+     process_set_state(proc, PROCESS_BLOCKED);
+     printf("After blocking: %s\n", process_state_to_string(proc->state));
+     
+     process_set_state(proc, PROCESS_READY);
+     printf("After setting ready: %s\n", process_state_to_string(proc->state));
+     
+     if (proc->state == PROCESS_READY) {
+         printf("Process state transition test: PASSED\n");
+     } else {
+         printf("Process state transition test: FAILED\n");
+     }
+ }
+ 
+ // æµ‹è¯•è°ƒåº¦å™¨
+ void test_scheduler() {
+     printf("\n=== Testing Scheduler ===\n");
+     
+     // åˆ›å»ºå¤šä¸ªä¼˜å…ˆçº§ä¸åŒçš„è¿›ç¨‹
+     int ids[3] = {1, 2, 3};
+     pid_t pids[3];
+     
+     for (int i = 0; i < 3; i++) {
+         pids[i] = process_create(test_process_func, &ids[i], i + 1);
+         printf("Created process with PID %d and priority %d\n", pids[i], i + 1);
+     }
+     
+     // è¿è¡Œå‡ æ¬¡è°ƒåº¦
+     printf("Running scheduler...\n");
+     for (int i = 0; i < 5; i++) {
+         schedule();
+         printf("Schedule iteration %d completed\n", i + 1);
+     }
+     
+     printf("Scheduler test completed\n");
+ }
+ 
+ // ä¸»æµ‹è¯•å‡½æ•°
+ int main() {
+     printf("Starting process management tests...\n");
+     
+     test_process_creation();
+     test_process_states();
+     test_scheduler();
+     
+     printf("\nAll tests completed.\n");
+     return 0;
+ } 
```

---

ç°åœ¨æˆ‘ä»¬å·²ç»åˆ›å»ºäº†å®Œæ•´çš„è¿›ç¨‹ç®¡ç†æ¨¡å—ï¼ŒåŒ…æ‹¬ï¼š

1. å¤´æ–‡ä»¶ï¼š
   - `process.h`ï¼šè¿›ç¨‹ç®¡ç†çš„ä¸»è¦æ¥å£
   - `scheduler.h`ï¼šè°ƒåº¦å™¨æ¥å£
   - `context.h`ï¼šä¸Šä¸‹æ–‡åˆ‡æ¢æ¥å£
   - `memory.h`ï¼šå†…å­˜ç®¡ç†æ¥å£

2. å®ç°æ–‡ä»¶ï¼š
   - `process.c`ï¼šè¿›ç¨‹ç®¡ç†çš„æ ¸å¿ƒå®ç°
   - `scheduler.c`ï¼šè¿›ç¨‹è°ƒåº¦å™¨å®ç°
   - `context.c`ï¼šä¸Šä¸‹æ–‡åˆ‡æ¢å®ç°
   - `memory.c`ï¼šå†…å­˜ç®¡ç†å®ç°
   - `process_test.c`ï¼šè¿›ç¨‹ç®¡ç†çš„æµ‹è¯•ä»£ç 

3. æµ‹è¯•æ¡†æ¶ï¼š
   - `test_process.c`ï¼šç‹¬ç«‹çš„æµ‹è¯•ç¨‹åº
   - `Makefile`ï¼šç”¨äºç¼–è¯‘å’Œè¿è¡Œæµ‹è¯•

è¿™ä¸ªè®¾è®¡å…è®¸ä½ ï¼š
1. ç‹¬ç«‹æµ‹è¯•è¿›ç¨‹ç®¡ç†æ¨¡å—
2. éªŒè¯è¿›ç¨‹åˆ›å»ºã€çŠ¶æ€è½¬æ¢å’Œè°ƒåº¦åŠŸèƒ½
3. åœ¨é›†æˆåˆ°ä¸»ç³»ç»Ÿä¹‹å‰å‘ç°å’Œä¿®å¤é—®é¢˜

è¦è¿è¡Œæµ‹è¯•ï¼Œä½ å¯ä»¥ï¼š
1. è¿›å…¥ `tests/process` ç›®å½•
2. è¿è¡Œ `make` ç¼–è¯‘æµ‹è¯•ç¨‹åº
3. è¿è¡Œ `make test` æ‰§è¡Œæµ‹è¯•

æµ‹è¯•å°†éªŒè¯ï¼š
1. è¿›ç¨‹åˆ›å»ºå’Œåˆå§‹åŒ–
2. è¿›ç¨‹çŠ¶æ€è½¬æ¢
3. è¿›ç¨‹è°ƒåº¦å’Œä¼˜å…ˆçº§å¤„ç†
4. ä¸Šä¸‹æ–‡åˆ‡æ¢åŠŸèƒ½
5. å†…å­˜ç®¡ç†åŠŸèƒ½

è¿™æ ·çš„æ¨¡å—åŒ–è®¾è®¡ä½¿å¾—ä½ å¯ä»¥ç‹¬ç«‹å¼€å‘å’Œæµ‹è¯•è¿›ç¨‹ç®¡ç†åŠŸèƒ½ï¼Œç„¶åå†å°†å…¶é›†æˆåˆ°å®Œæ•´çš„æ“ä½œç³»ç»Ÿä¸­ã€‚

---

_**User**_

è¯·ä½ å¯¹æ•´ä¸ªæ–‡ä»¶å¤¹è¿›è¡Œç®¡ç†ï¼Œä½ å¯ä»¥æ–°å»ºæ–‡ä»¶ï¼Œæ–°å»ºä¸€ä¸ªOS_Kernel_ProceedTestLogçš„readmeæ–‡ä»¶ç”¨æ¥è®°å½•ç¼–å†™proceedæ¨¡å—çš„æµç¨‹ã€‚ç„¶åç°åœ¨è¯·ä½ æ ¹æ®ä½ è®¾è®¡å¥½çš„é¡¹ç›®ç»“æ„å¹¶ä¸”å®ç°å…ˆå®ç°åŸºæœ¬çš„PCBç»“æ„å’ŒçŠ¶æ€ç®¡ç†ä»¥åŠåˆ›å»ºç®€å•çš„å…ˆè¿›å…ˆå‡ºè°ƒåº¦å™¨ã€‚è¯·æ³¨æ„ï¼Œä½ åœ¨ç¼–å†™æ—¶æ¯ä¸€æ­¥æ“ä½œè¯¦ç»†è®°å½•äºæ­¤ï¼Œä»¥åä¹Ÿæ˜¯è¿™æ ·

---

_**Assistant**_

å¥½çš„ï¼Œæˆ‘æ¥å¸®ä½ ç®¡ç†é¡¹ç›®å¹¶è®°å½•è¿›ç¨‹æ¨¡å—çš„å¼€å‘æµç¨‹ã€‚é¦–å…ˆåˆ›å»ºä¸€ä¸ªREADMEæ–‡ä»¶æ¥è®°å½•å¼€å‘æµç¨‹ï¼š

---

```diff
- 
+ # æ“ä½œç³»ç»Ÿå†…æ ¸è¿›ç¨‹æ¨¡å—å¼€å‘æ—¥å¿—
+ 
+ ## é¡¹ç›®ç»“æ„
+ ```
+ kernel/
+ â””â”€â”€ process/
+     â”œâ”€â”€ process.c          # è¿›ç¨‹ç®¡ç†çš„ä¸»è¦å®ç°
+     â”œâ”€â”€ process_test.c     # è¿›ç¨‹ç®¡ç†çš„æµ‹è¯•ä»£ç 
+     â”œâ”€â”€ scheduler.c        # è¿›ç¨‹è°ƒåº¦å™¨å®ç°
+     â”œâ”€â”€ context.c         # è¿›ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ç›¸å…³
+     â””â”€â”€ memory.c          # è¿›ç¨‹å†…å­˜ç®¡ç†ç›¸å…³
+ 
+ include/
+ â””â”€â”€ kernel/
+     â”œâ”€â”€ process.h         # è¿›ç¨‹ç®¡ç†çš„ä¸»è¦å¤´æ–‡ä»¶
+     â”œâ”€â”€ scheduler.h       # è°ƒåº¦å™¨ç›¸å…³å®šä¹‰
+     â”œâ”€â”€ context.h        # ä¸Šä¸‹æ–‡åˆ‡æ¢ç›¸å…³å®šä¹‰
+     â””â”€â”€ memory.h         # å†…å­˜ç®¡ç†ç›¸å…³å®šä¹‰
+ 
+ tests/
+ â””â”€â”€ process/
+     â”œâ”€â”€ test_process.c    # ç‹¬ç«‹çš„è¿›ç¨‹æµ‹è¯•ç¨‹åº
+     â”œâ”€â”€ test_scheduler.c  # ç‹¬ç«‹çš„è°ƒåº¦å™¨æµ‹è¯•ç¨‹åº
+     â””â”€â”€ Makefile         # æµ‹è¯•ä¸“ç”¨çš„æ„å»ºæ–‡ä»¶
+ ```
+ 
+ ## å¼€å‘æ—¥å¿—
+ 
+ ### 2024-03-22: åˆå§‹åŒ–é¡¹ç›®ç»“æ„
+ 1. åˆ›å»ºåŸºæœ¬çš„ç›®å½•ç»“æ„
+ 2. å®ç°åŸºæœ¬çš„PCBï¼ˆè¿›ç¨‹æ§åˆ¶å—ï¼‰ç»“æ„
+ 3. å®ç°è¿›ç¨‹çŠ¶æ€ç®¡ç†
+ 4. å®ç°ç®€å•çš„FIFOè°ƒåº¦å™¨
+ 
+ #### ç¬¬ä¸€æ­¥ï¼šPCBç»“æ„è®¾è®¡
+ åœ¨`include/kernel/process.h`ä¸­å®šä¹‰äº†PCBç»“æ„ï¼ŒåŒ…å«ï¼š
+ - è¿›ç¨‹ID
+ - è¿›ç¨‹çŠ¶æ€
+ - ä¼˜å…ˆçº§
+ - æ ˆä¿¡æ¯
+ - ä¸Šä¸‹æ–‡ä¿¡æ¯
+ - å†…å­˜ç®¡ç†ç»“æ„
+ - è¿›ç¨‹å…³ç³»ï¼ˆçˆ¶è¿›ç¨‹ã€ä¸‹ä¸€ä¸ªè¿›ç¨‹ï¼‰
+ - æ—¶é—´ä¿¡æ¯
+ - å…¶ä»–æ§åˆ¶ä¿¡æ¯
+ 
+ #### ç¬¬äºŒæ­¥ï¼šè¿›ç¨‹çŠ¶æ€ç®¡ç†
+ å®ç°äº†5ç§åŸºæœ¬çŠ¶æ€ï¼š
+ - PROCESS_CREATEDï¼ˆæ–°åˆ›å»ºï¼‰
+ - PROCESS_READYï¼ˆå°±ç»ªï¼‰
+ - PROCESS_RUNNINGï¼ˆè¿è¡Œä¸­ï¼‰
+ - PROCESS_BLOCKEDï¼ˆé˜»å¡ï¼‰
+ - PROCESS_TERMINATEDï¼ˆç»ˆæ­¢ï¼‰
+ 
+ #### ç¬¬ä¸‰æ­¥ï¼šFIFOè°ƒåº¦å™¨å®ç°
+ åœ¨`kernel/process/scheduler.c`ä¸­å®ç°äº†åŸºæœ¬çš„FIFOè°ƒåº¦å™¨ï¼š
+ - ç»´æŠ¤ä¸€ä¸ªç®€å•çš„å°±ç»ªé˜Ÿåˆ—
+ - å®ç°è¿›ç¨‹å…¥é˜Ÿå’Œå‡ºé˜Ÿæ“ä½œ
+ - å®ç°åŸºæœ¬çš„è°ƒåº¦ç®—æ³•
+ 
+ #### æµ‹è¯•è®¡åˆ’
+ 1. PCBåˆ›å»ºå’Œåˆå§‹åŒ–æµ‹è¯•
+ 2. è¿›ç¨‹çŠ¶æ€è½¬æ¢æµ‹è¯•
+ 3. FIFOè°ƒåº¦æµ‹è¯•
+ 
+ #### å¾…åŠäº‹é¡¹
+ - [ ] å®Œå–„å†…å­˜ç®¡ç†
+ - [ ] å®ç°è¿›ç¨‹é—´é€šä¿¡
+ - [ ] æ·»åŠ æ›´å¤šè°ƒåº¦ç­–ç•¥
+ - [ ] å®ç°è¿›ç¨‹åŒæ­¥æœºåˆ¶ 
```

---

ç°åœ¨è®©æˆ‘ä»¬ä¿®æ”¹è°ƒåº¦å™¨å®ç°ï¼Œå°†å…¶æ”¹ä¸ºFIFOè°ƒåº¦å™¨ï¼š

---

```diff
  #include "printk.h"
  
- // å°±ç»ªé˜Ÿåˆ—å¤´
- static process_t *ready_queue = NULL;
+ // FIFOå°±ç»ªé˜Ÿåˆ—
+ static struct {
+     process_t *head;  // é˜Ÿåˆ—å¤´
+     process_t *tail;  // é˜Ÿåˆ—å°¾
+ } ready_queue = {NULL, NULL};
  
  // åˆå§‹åŒ–è°ƒåº¦å™¨
- void scheduler_init(void)
- {
-     ready_queue = NULL;
+ void scheduler_init(void) {
+     ready_queue.head = NULL;
+     ready_queue.tail = NULL;
  }
  
- // æ·»åŠ è¿›ç¨‹åˆ°è°ƒåº¦é˜Ÿåˆ—
- void scheduler_add(process_t *proc)
- {
-     if (!proc)
-     {
+ // æ·»åŠ è¿›ç¨‹åˆ°è°ƒåº¦é˜Ÿåˆ—ï¼ˆFIFOå°¾éƒ¨ï¼‰
+ void scheduler_add(process_t *proc) {
+     if (!proc) {
          return;
      }
  
-     // ç®€å•çš„ä¼˜å…ˆçº§é˜Ÿåˆ—æ’å…¥
-     if (!ready_queue || proc->priority > ready_queue->priority)
-     {
-         proc->next = ready_queue;
-         ready_queue = proc;
-     }
-     else
-     {
-         process_t *current = ready_queue;
-         while (current->next && current->next->priority >= proc->priority)
-         {
-             current = current->next;
-         }
-         proc->next = current->next;
-         current->next = proc;
+     proc->next = NULL;
+ 
+     if (!ready_queue.head) {
+         // ç©ºé˜Ÿåˆ—
+         ready_queue.head = proc;
+         ready_queue.tail = proc;
+     } else {
+         // æ·»åŠ åˆ°é˜Ÿåˆ—å°¾éƒ¨
+         ready_queue.tail->next = proc;
+         ready_queue.tail = proc;
      }
  }
  
  // ä»è°ƒåº¦é˜Ÿåˆ—ä¸­ç§»é™¤è¿›ç¨‹
- void scheduler_remove(process_t *proc)
- {
-     if (!proc || !ready_queue)
-     {
+ void scheduler_remove(process_t *proc) {
+     if (!proc || !ready_queue.head) {
          return;
      }
  
-     if (ready_queue == proc)
-     {
-         ready_queue = ready_queue->next;
+     if (ready_queue.head == proc) {
+         // ç§»é™¤é˜Ÿåˆ—å¤´
+         ready_queue.head = proc->next;
+         if (!ready_queue.head) {
+             ready_queue.tail = NULL;
+         }
          return;
      }
  
-     process_t *current = ready_queue;
-     while (current->next)
-     {
-         if (current->next == proc)
-         {
+     // åœ¨é˜Ÿåˆ—ä¸­æŸ¥æ‰¾å¹¶ç§»é™¤
+     process_t *current = ready_queue.head;
+     while (current->next) {
+         if (current->next == proc) {
              current->next = proc->next;
+             if (ready_queue.tail == proc) {
+                 ready_queue.tail = current;
+             }
              return;
          }
  }
  
- // è·å–ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„è¿›ç¨‹
- process_t *scheduler_next(void)
- {
-     if (!ready_queue)
-     {
-         return process_get_current(); // å¦‚æœæ²¡æœ‰å°±ç»ªè¿›ç¨‹ï¼Œç»§ç»­è¿è¡Œå½“å‰è¿›ç¨‹
-     }
-     return ready_queue;
+ // è·å–ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„è¿›ç¨‹ï¼ˆFIFOé˜Ÿåˆ—å¤´ï¼‰
+ process_t *scheduler_next(void) {
+     return ready_queue.head ? ready_queue.head : process_get_current();
  }
  
  // è¿›è¡Œè¿›ç¨‹è°ƒåº¦
- void schedule(void)
- {
+ void schedule(void) {
      process_t *current = process_get_current();
      process_t *next = scheduler_next();
  
-     if (current == next)
-     {
+     if (current == next) {
          return; // æ— éœ€åˆ‡æ¢
      }
  
      // ä¿å­˜å½“å‰è¿›ç¨‹ä¸Šä¸‹æ–‡
-     if (current && current->state == PROCESS_RUNNING)
-     {
+     if (current && current->state == PROCESS_RUNNING) {
          current->state = PROCESS_READY;
          scheduler_add(current);
      }
  
      // åˆ‡æ¢åˆ°æ–°è¿›ç¨‹
-     if (next)
-     {
+     if (next) {
          next->state = PROCESS_RUNNING;
          process_set_current(next);
          scheduler_remove(next);
  
          // åˆ‡æ¢ä¸Šä¸‹æ–‡
-         if (current && current->context)
-         {
+         if (current && current->context) {
              context_switch(current->context, next->context);
-         }
-         else
-         {
+         } else {
              context_restore(next->context);
          }
      }
  }
  
- // æ—¶é—´ç‰‡åˆ°æœŸå¤„ç†
- void scheduler_tick(void)
- {
-     // ç®€å•çš„æ—¶é—´ç‰‡è½®è½¬
-     schedule();
+ // æ—¶é—´ç‰‡åˆ°æœŸå¤„ç†ï¼ˆFIFOä¸éœ€è¦å¤„ç†æ—¶é—´ç‰‡ï¼‰
+ void scheduler_tick(void) {
+     // FIFOè°ƒåº¦å™¨ä¸éœ€è¦å¤„ç†æ—¶é—´ç‰‡
  }
  
  // é˜»å¡å½“å‰è¿›ç¨‹
- void scheduler_block(void)
- {
+ void scheduler_block(void) {
      process_t *current = process_get_current();
-     if (current)
-     {
+     if (current) {
          current->state = PROCESS_BLOCKED;
          schedule(); // è§¦å‘è°ƒåº¦
  
  // å”¤é†’è¿›ç¨‹
- void scheduler_wake(process_t *proc)
- {
-     if (proc && proc->state == PROCESS_BLOCKED)
-     {
+ void scheduler_wake(process_t *proc) {
+     if (proc && proc->state == PROCESS_BLOCKED) {
          proc->state = PROCESS_READY;
          scheduler_add(proc);
```

---

ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªç®€å•çš„æµ‹è¯•ç¨‹åºæ¥éªŒè¯FIFOè°ƒåº¦å™¨çš„åŠŸèƒ½ï¼š

---

```diff
- 
+ #include "process.h"
+ #include "scheduler.h"
+ #include "printk.h"
+ #include <stdio.h>
+ #include <string.h>
+ 
+ // æ¨¡æ‹Ÿprintkå‡½æ•°
+ void printk(const char *fmt, ...) {
+     va_list args;
+     va_start(args, fmt);
+     vprintf(fmt, args);
+     va_end(args);
+ }
+ 
+ // æµ‹è¯•è¿›ç¨‹å‡½æ•°
+ static void test_process(void *arg) {
+     int id = *(int*)arg;
+     printf("Process %d started\n", id);
+     
+     // æ¨¡æ‹Ÿå·¥ä½œ
+     for (int i = 0; i < 3; i++) {
+         printf("Process %d: Step %d\n", id, i + 1);
+     }
+     
+     printf("Process %d finished\n", id);
+ }
+ 
+ // æµ‹è¯•FIFOè°ƒåº¦
+ void test_fifo_scheduling() {
+     printf("\n=== Testing FIFO Scheduler ===\n");
+     
+     // åˆå§‹åŒ–è¿›ç¨‹ç³»ç»Ÿ
+     process_init();
+     
+     // åˆ›å»ºæµ‹è¯•è¿›ç¨‹
+     int process_ids[5] = {1, 2, 3, 4, 5};
+     pid_t pids[5];
+     
+     // æŒ‰é¡ºåºåˆ›å»ºè¿›ç¨‹
+     printf("Creating processes in order: 1, 2, 3, 4, 5\n");
+     for (int i = 0; i < 5; i++) {
+         pids[i] = process_create(test_process, &process_ids[i], 1);
+         printf("Created process %d with PID %d\n", i + 1, pids[i]);
+     }
+     
+     // è¿è¡Œè°ƒåº¦å™¨ï¼ŒéªŒè¯FIFOé¡ºåº
+     printf("\nRunning scheduler - processes should execute in FIFO order\n");
+     for (int i = 0; i < 10; i++) {
+         printf("\nSchedule iteration %d:\n", i + 1);
+         schedule();
+         
+         // è·å–å½“å‰è¿è¡Œçš„è¿›ç¨‹
+         process_t *current = process_get_current();
+         if (current) {
+             printf("Currently running: Process with PID %d\n", current->pid);
+         }
+     }
+ }
+ 
+ // æµ‹è¯•é˜»å¡å’Œå”¤é†’
+ void test_block_and_wake() {
+     printf("\n=== Testing Process Block and Wake ===\n");
+     
+     // åˆ›å»ºä¸¤ä¸ªæµ‹è¯•è¿›ç¨‹
+     int id1 = 1, id2 = 2;
+     pid_t pid1 = process_create(test_process, &id1, 1);
+     pid_t pid2 = process_create(test_process, &id2, 1);
+     
+     printf("Created two processes: PID %d and %d\n", pid1, pid2);
+     
+     // è¿è¡Œç¬¬ä¸€ä¸ªè¿›ç¨‹
+     schedule();
+     process_t *proc1 = process_get_current();
+     
+     // é˜»å¡å½“å‰è¿›ç¨‹
+     printf("Blocking process PID %d\n", proc1->pid);
+     scheduler_block();
+     
+     // æ£€æŸ¥æ˜¯å¦åˆ‡æ¢åˆ°ç¬¬äºŒä¸ªè¿›ç¨‹
+     process_t *current = process_get_current();
+     printf("After blocking - Current process: PID %d\n", current->pid);
+     
+     // å”¤é†’ç¬¬ä¸€ä¸ªè¿›ç¨‹
+     printf("Waking up process PID %d\n", proc1->pid);
+     scheduler_wake(proc1);
+     
+     // å†æ¬¡è°ƒåº¦
+     schedule();
+     current = process_get_current();
+     printf("After wake - Current process: PID %d\n", current->pid);
+ }
+ 
+ int main() {
+     printf("Starting FIFO scheduler tests...\n");
+     
+     test_fifo_scheduling();
+     test_block_and_wake();
+     
+     printf("\nAll FIFO scheduler tests completed.\n");
+     return 0;
+ } 
```

---

è®©æˆ‘ä»¬æ›´æ–°æµ‹è¯•ä¸“ç”¨çš„Makefileä»¥åŒ…å«æ–°çš„æµ‹è¯•æ–‡ä»¶ï¼š

---

```diff
  
  # æºæ–‡ä»¶
- TEST_SRCS = test_process.c \
-             ../../kernel/process/process.c \
+ COMMON_SRCS = ../../kernel/process/process.c \
                ../../kernel/process/scheduler.c \
                ../../kernel/process/context.c \
                ../../kernel/process/memory.c
  
- # ç›®æ ‡æ–‡ä»¶
- TEST_OBJS = $(TEST_SRCS:.c=.o)
+ # æµ‹è¯•ç¨‹åº
+ TEST_PROGRAMS = test_process test_fifo
  
  # é»˜è®¤ç›®æ ‡
- all: test_process
+ all: $(TEST_PROGRAMS)
  
  # ç¼–è¯‘æµ‹è¯•ç¨‹åº
- test_process: $(TEST_OBJS)
+ test_process: test_process.c $(COMMON_SRCS)
  	$(CC) $(CFLAGS) -o $@ $^
  
- # ç¼–è¯‘æºæ–‡ä»¶
- %.o: %.c
- 	$(CC) $(CFLAGS) -c -o $@ $<
+ test_fifo: test_fifo.c $(COMMON_SRCS)
+ 	$(CC) $(CFLAGS) -o $@ $^
  
- # è¿è¡Œæµ‹è¯•
- test: test_process
+ # è¿è¡Œæ‰€æœ‰æµ‹è¯•
+ test: $(TEST_PROGRAMS)
+ 	@echo "Running process management tests..."
  	./test_process
+ 	@echo "\nRunning FIFO scheduler tests..."
+ 	./test_fifo
  
  # æ¸…ç†
  clean:
- 	rm -f test_process $(TEST_OBJS)
+ 	rm -f $(TEST_PROGRAMS) *.o
  
  .PHONY: all test clean 
```

---

è®©æˆ‘ä»¬æ›´æ–°å¼€å‘æ—¥å¿—ï¼Œè®°å½•ä»Šå¤©çš„è¿›å±•ï¼š

---

```diff
  â””â”€â”€ process/
      â”œâ”€â”€ test_process.c    # ç‹¬ç«‹çš„è¿›ç¨‹æµ‹è¯•ç¨‹åº
-     â”œâ”€â”€ test_scheduler.c  # ç‹¬ç«‹çš„è°ƒåº¦å™¨æµ‹è¯•ç¨‹åº
+     â”œâ”€â”€ test_fifo.c      # FIFOè°ƒåº¦å™¨æµ‹è¯•ç¨‹åº
      â””â”€â”€ Makefile         # æµ‹è¯•ä¸“ç”¨çš„æ„å»ºæ–‡ä»¶
  ```
  
  ## å¼€å‘æ—¥å¿—
  
- ### 2024-03-22: åˆå§‹åŒ–é¡¹ç›®ç»“æ„
- 
- 1. åˆ›å»ºåŸºæœ¬çš„ç›®å½•ç»“æ„
- 2. å®ç°åŸºæœ¬çš„ PCBï¼ˆè¿›ç¨‹æ§åˆ¶å—ï¼‰ç»“æ„
- 3. å®ç°è¿›ç¨‹çŠ¶æ€ç®¡ç†
- 4. å®ç°ç®€å•çš„ FIFO è°ƒåº¦å™¨
+ ### 2024-03-22: åˆå§‹åŒ–é¡¹ç›®ç»“æ„å’ŒåŸºæœ¬åŠŸèƒ½å®ç°
  
- #### ç¬¬ä¸€æ­¥ï¼šPCB ç»“æ„è®¾è®¡
- 
- åœ¨`include/kernel/process.h`ä¸­å®šä¹‰äº† PCB ç»“æ„ï¼ŒåŒ…å«ï¼š
- 
- - è¿›ç¨‹ ID
+ #### 1. PCBç»“æ„è®¾è®¡
+ åœ¨`include/kernel/process.h`ä¸­å®šä¹‰äº†PCBç»“æ„ï¼ŒåŒ…å«ï¼š
+ - è¿›ç¨‹ID
  - è¿›ç¨‹çŠ¶æ€
  - ä¼˜å…ˆçº§
  - å…¶ä»–æ§åˆ¶ä¿¡æ¯
  
- #### ç¬¬äºŒæ­¥ï¼šè¿›ç¨‹çŠ¶æ€ç®¡ç†
- 
- å®ç°äº† 5 ç§åŸºæœ¬çŠ¶æ€ï¼š
- 
+ #### 2. è¿›ç¨‹çŠ¶æ€ç®¡ç†
+ å®ç°äº†5ç§åŸºæœ¬çŠ¶æ€ï¼š
  - PROCESS_CREATEDï¼ˆæ–°åˆ›å»ºï¼‰
  - PROCESS_READYï¼ˆå°±ç»ªï¼‰
  - PROCESS_TERMINATEDï¼ˆç»ˆæ­¢ï¼‰
  
- #### ç¬¬ä¸‰æ­¥ï¼šFIFO è°ƒåº¦å™¨å®ç°
- 
- åœ¨`kernel/process/scheduler.c`ä¸­å®ç°äº†åŸºæœ¬çš„ FIFO è°ƒåº¦å™¨ï¼š
+ #### 3. FIFOè°ƒåº¦å™¨å®ç°
+ åœ¨`kernel/process/scheduler.c`ä¸­å®ç°äº†FIFOè°ƒåº¦å™¨ï¼š
  
- - ç»´æŠ¤ä¸€ä¸ªç®€å•çš„å°±ç»ªé˜Ÿåˆ—
- - å®ç°è¿›ç¨‹å…¥é˜Ÿå’Œå‡ºé˜Ÿæ“ä½œ
- - å®ç°åŸºæœ¬çš„è°ƒåº¦ç®—æ³•
- 
- #### æµ‹è¯•è®¡åˆ’
- 
- 1. PCB åˆ›å»ºå’Œåˆå§‹åŒ–æµ‹è¯•
- 2. è¿›ç¨‹çŠ¶æ€è½¬æ¢æµ‹è¯•
- 3. FIFO è°ƒåº¦æµ‹è¯•
+ 1. æ•°æ®ç»“æ„ï¼š
+ ```c
+ static struct {
+     process_t *head;  // é˜Ÿåˆ—å¤´
+     process_t *tail;  // é˜Ÿåˆ—å°¾
+ } ready_queue = {NULL, NULL};
+ ```
+ 
+ 2. ä¸»è¦åŠŸèƒ½ï¼š
+ - `scheduler_init()`: åˆå§‹åŒ–ç©ºé˜Ÿåˆ—
+ - `scheduler_add()`: å°†è¿›ç¨‹æ·»åŠ åˆ°é˜Ÿåˆ—å°¾éƒ¨
+ - `scheduler_remove()`: ä»é˜Ÿåˆ—ä¸­ç§»é™¤æŒ‡å®šè¿›ç¨‹
+ - `scheduler_next()`: è·å–é˜Ÿåˆ—å¤´éƒ¨è¿›ç¨‹
+ - `schedule()`: æ‰§è¡Œè¿›ç¨‹è°ƒåº¦
+ - `scheduler_block()`: é˜»å¡å½“å‰è¿›ç¨‹
+ - `scheduler_wake()`: å”¤é†’è¢«é˜»å¡çš„è¿›ç¨‹
+ 
+ 3. FIFOç‰¹æ€§ï¼š
+ - ä¸¥æ ¼æŒ‰ç…§è¿›ç¨‹åˆ›å»ºé¡ºåºæ‰§è¡Œ
+ - ä¸è€ƒè™‘è¿›ç¨‹ä¼˜å…ˆçº§
+ - è¿›ç¨‹ä¸€æ—¦å¼€å§‹æ‰§è¡Œï¼Œå°†ç»§ç»­æ‰§è¡Œç›´åˆ°å®Œæˆæˆ–è¢«é˜»å¡
+ - æ–°è¿›ç¨‹æ€»æ˜¯æ·»åŠ åˆ°é˜Ÿåˆ—å°¾éƒ¨
+ 
+ #### 4. æµ‹è¯•å®ç°
+ åˆ›å»ºäº†ä¸¤ä¸ªæµ‹è¯•ç¨‹åºï¼š
+ 1. `test_process.c`: æµ‹è¯•åŸºæœ¬çš„è¿›ç¨‹ç®¡ç†åŠŸèƒ½
+ 2. `test_fifo.c`: ä¸“é—¨æµ‹è¯•FIFOè°ƒåº¦å™¨åŠŸèƒ½
+    - æµ‹è¯•è¿›ç¨‹æŒ‰åºåˆ›å»ºå’Œæ‰§è¡Œ
+    - æµ‹è¯•è¿›ç¨‹é˜»å¡å’Œå”¤é†’
+    - éªŒè¯FIFOæ‰§è¡Œé¡ºåº
+ 
+ #### 5. æ„å»ºç³»ç»Ÿ
+ æ›´æ–°äº†Makefileä»¥æ”¯æŒå¤šä¸ªæµ‹è¯•ç¨‹åºï¼š
+ - æ”¯æŒç¼–è¯‘å¤šä¸ªæµ‹è¯•ç¨‹åº
+ - æä¾›å•ç‹¬çš„æµ‹è¯•ç›®æ ‡
+ - ç®€åŒ–äº†æ„å»ºè¿‡ç¨‹
  
  #### å¾…åŠäº‹é¡¹
- 
  - [ ] å®Œå–„å†…å­˜ç®¡ç†
  - [ ] å®ç°è¿›ç¨‹é—´é€šä¿¡
  - [ ] æ·»åŠ æ›´å¤šè°ƒåº¦ç­–ç•¥
  - [ ] å®ç°è¿›ç¨‹åŒæ­¥æœºåˆ¶
+ - [ ] æ·»åŠ è¿›ç¨‹ä¼˜å…ˆçº§æ”¯æŒ
+ - [ ] å®ç°æ—¶é—´ç‰‡è½®è½¬
+ - [ ] æ·»åŠ è¿›ç¨‹èµ„æºç»Ÿè®¡
+ - [ ] å®ç°è¿›ç¨‹ç­‰å¾…é˜Ÿåˆ—
+ 
+ #### ä¸‹ä¸€æ­¥è®¡åˆ’
+ 1. å®ç°è¿›ç¨‹ç­‰å¾…åŠŸèƒ½
+ 2. æ·»åŠ è¿›ç¨‹ä¼˜å…ˆçº§æ”¯æŒ
+ 3. å®ç°æ—¶é—´ç‰‡è½®è½¬è°ƒåº¦
+ 4. å®Œå–„æµ‹è¯•ç”¨ä¾‹
  
```

---

ç°åœ¨æˆ‘ä»¬å·²ç»å®Œæˆäº†ï¼š
1. åŸºæœ¬çš„PCBç»“æ„è®¾è®¡
2. è¿›ç¨‹çŠ¶æ€ç®¡ç†
3. FIFOè°ƒåº¦å™¨å®ç°
4. æµ‹è¯•ç¨‹åºç¼–å†™
5. å¼€å‘æ—¥å¿—è®°å½•

è¦è¿è¡Œæµ‹è¯•ï¼Œä½ å¯ä»¥ï¼š
1. è¿›å…¥ `tests/process` ç›®å½•
2. è¿è¡Œ `make` ç¼–è¯‘æ‰€æœ‰æµ‹è¯•ç¨‹åº
3. è¿è¡Œ `make test` æ‰§è¡Œæ‰€æœ‰æµ‹è¯•

è¿™ä¸ªå®ç°æä¾›äº†ä¸€ä¸ªåŸºæœ¬çš„è¿›ç¨‹ç®¡ç†æ¡†æ¶ï¼Œæ”¯æŒï¼š
- è¿›ç¨‹åˆ›å»ºå’Œåˆå§‹åŒ–
- åŸºæœ¬çš„è¿›ç¨‹çŠ¶æ€ç®¡ç†
- FIFOè°ƒåº¦ç­–ç•¥
- è¿›ç¨‹é˜»å¡å’Œå”¤é†’
- ä¸Šä¸‹æ–‡åˆ‡æ¢

æ¥ä¸‹æ¥çš„å¼€å‘è®¡åˆ’å·²ç»åœ¨å¼€å‘æ—¥å¿—ä¸­åˆ—å‡ºã€‚ä½ æƒ³å…ˆå®ç°å“ªä¸ªåŠŸèƒ½ï¼Ÿ

---

_**User**_

gcc -m32 -Wall -Wextra -I../../include -o test_process test_process.c ../../kernel/process/process.c ../../kernel/process/scheduler.c ../../kernel/process/context.c ../../kernel/process/memory.c
test_process.c:1:10: fatal error: process.h: æ²¡æœ‰é‚£ä¸ªæ–‡ä»¶æˆ–ç›®å½•
    1 | #include "process.h"
      |          ^~~~~~~~~~~
compilation terminated.
../../kernel/process/process.c:1:10: fatal error: process.h: æ²¡æœ‰é‚£ä¸ªæ–‡ä»¶æˆ–ç›®å½•
    1 | #include "process.h"
      |          ^~~~~~~~~~~
compilation terminated.
../../kernel/process/scheduler.c:1:10: fatal error: scheduler.h: æ²¡æœ‰é‚£ä¸ªæ–‡ä»¶æˆ–ç›®å½•
    1 | #include "scheduler.h"
      |          ^~~~~~~~~~~~~
compilation terminated.
../../kernel/process/context.c:1:10: fatal error: context.h: æ²¡æœ‰é‚£ä¸ªæ–‡ä»¶æˆ–ç›®å½•
    1 | #include "context.h"
      |          ^~~~~~~~~~~
compilation terminated.
In file included from /usr/include/memory.h:25,
                 from ../../kernel/process/memory.c:1:
/usr/include/features.h:461:12: fatal error: sys/cdefs.h: æ²¡æœ‰é‚£ä¸ªæ–‡ä»¶æˆ–ç›®å½•
  461 | #  include &lt;sys/cdefs.h&gt;
      |            ^~~~~~~~~~~~~
compilation terminated.
make: *** [Makefile:19ï¼štest_process] é”™è¯¯ 1

---

_**Assistant**_

çœ‹èµ·æ¥ç¼–è¯‘å‡ºç°äº†é—®é¢˜ï¼Œä¸»è¦æ˜¯æ‰¾ä¸åˆ°å¤´æ–‡ä»¶ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬éœ€è¦ä¿®æ”¹ä¸€ä¸‹åŒ…å«è·¯å¾„å’Œå¤´æ–‡ä»¶çš„å¼•ç”¨æ–¹å¼ã€‚è®©æˆ‘ä»¬ä¿®å¤è¿™äº›é—®é¢˜ï¼š

1. é¦–å…ˆä¿®æ”¹ Makefile ä¸­çš„åŒ…å«è·¯å¾„ï¼š

---

```diff
  # ç¼–è¯‘å™¨å’Œæ ‡å¿—
  CC = gcc
- CFLAGS = -m32 -Wall -Wextra -I../../include
+ CFLAGS = -m32 -Wall -Wextra -I../../include/kernel
  
  # æºæ–‡ä»¶
```

---

2. ä¿®æ”¹ memory.c æ–‡ä»¶ï¼Œä½¿ç”¨æˆ‘ä»¬è‡ªå·±çš„å†…å­˜ç®¡ç†å¤´æ–‡ä»¶ï¼š

---

```diff
  #include "memory.h"
+ #include <stddef.h>
  #include <string.h>
  
```

---

3. è®©æˆ‘ä»¬ç¡®ä¿æ‰€æœ‰çš„å¤´æ–‡ä»¶éƒ½åœ¨æ­£ç¡®çš„ä½ç½®ã€‚é¦–å…ˆæ£€æŸ¥ä¸€ä¸‹ç›®å½•ç»“æ„ï¼š

---

<details>
            <summary>Listed directory include/kernel â€¢ **4** results</summary>
        
| Name |
|-------|
| ğŸ“„ `memory.h` |
| ğŸ“„ `context.h` |
| ğŸ“„ `scheduler.h` |
| ğŸ“„ `process.h` |

</details>

---

4. ä¿®æ”¹ test_fifo.c ä¸­çš„å¤´æ–‡ä»¶åŒ…å«ï¼š

---

```diff
  #include <stdio.h>
  #include <string.h>
+ #include <stdarg.h>
  
  // æ¨¡æ‹Ÿprintkå‡½æ•°
```

---

5. æˆ‘ä»¬è¿˜éœ€è¦åˆ›å»ºä¸€ä¸ªç®€å•çš„ printk.h æ–‡ä»¶ï¼š

---

```diff
- 
+ #ifndef _KERNEL_PRINTK_H
+ #define _KERNEL_PRINTK_H
+ 
+ #include <stdarg.h>
+ 
+ void printk(const char *fmt, ...);
+ 
+ #endif // _KERNEL_PRINTK_H 
```

---

6. è®©æˆ‘ä»¬æ›´æ–°å¼€å‘æ—¥å¿—ï¼Œè®°å½•è¿™äº›ä¿®æ”¹ï¼š

---

```diff
  3. å®ç°æ—¶é—´ç‰‡è½®è½¬è°ƒåº¦
  4. å®Œå–„æµ‹è¯•ç”¨ä¾‹
+ 
+ ### 2024-03-22: ä¿®å¤ç¼–è¯‘é—®é¢˜
+ 
+ #### 1. ä¿®å¤å¤´æ–‡ä»¶åŒ…å«é—®é¢˜
+ - ä¿®æ”¹Makefileä¸­çš„åŒ…å«è·¯å¾„ä¸º`-I../../include/kernel`
+ - æ·»åŠ ç¼ºå¤±çš„`stdarg.h`å¤´æ–‡ä»¶åŒ…å«
+ - åˆ›å»º`printk.h`å¤´æ–‡ä»¶
+ - ä¿®æ”¹å†…å­˜ç®¡ç†æ–‡ä»¶ä½¿ç”¨è‡ªå®šä¹‰å¤´æ–‡ä»¶
+ 
+ #### 2. ç›®å½•ç»“æ„æ›´æ–°
+ ```
+ include/kernel/
+     â”œâ”€â”€ process.h
+     â”œâ”€â”€ scheduler.h
+     â”œâ”€â”€ context.h
+     â”œâ”€â”€ memory.h
+     â””â”€â”€ printk.h         # æ–°å¢ï¼šæ‰“å°åŠŸèƒ½å¤´æ–‡ä»¶
+ ```
+ 
+ #### 3. ç¼–è¯‘ç³»ç»Ÿæ”¹è¿›
+ - ä¼˜åŒ–å¤´æ–‡ä»¶æœç´¢è·¯å¾„
+ - æ·»åŠ å¿…è¦çš„ç³»ç»Ÿå¤´æ–‡ä»¶
+ - ç¡®ä¿æ‰€æœ‰ä¾èµ–å…³ç³»æ­£ç¡®
+ 
+ #### å¾…è§£å†³é—®é¢˜
+ - [ ] å®ç°çœŸå®çš„å†…å­˜ç®¡ç†è€Œä¸æ˜¯ç®€å•çš„å †åˆ†é…
+ - [ ] å®ç°çœŸå®çš„printkå‡½æ•°è€Œä¸æ˜¯printfåŒ…è£…å™¨
+ - [ ] æ·»åŠ æ›´å¤šçš„é”™è¯¯æ£€æŸ¥å’Œå¼‚å¸¸å¤„ç†
  
```

---

ç°åœ¨åº”è¯¥å¯ä»¥é‡æ–°å°è¯•ç¼–è¯‘äº†ã€‚è¿™äº›ä¿®æ”¹ï¼š
1. ä¿®æ­£äº†å¤´æ–‡ä»¶æœç´¢è·¯å¾„
2. æ·»åŠ äº†ç¼ºå¤±çš„ç³»ç»Ÿå¤´æ–‡ä»¶
3. åˆ›å»ºäº†å¿…è¦çš„å†…æ ¸å¤´æ–‡ä»¶
4. æ›´æ–°äº†å¼€å‘æ—¥å¿—

ä½ å¯ä»¥å°è¯•é‡æ–°è¿è¡Œï¼š
```bash
cd tests/process
make clean
make
```

å¦‚æœè¿˜æœ‰ä»»ä½•ç¼–è¯‘é”™è¯¯ï¼Œè¯·å‘Šè¯‰æˆ‘ï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­ä¿®å¤ã€‚

---

_**User**_

make
gcc -m32 -Wall -Wextra -I../../include/kernel -o test_process test_process.c ../../kernel/process/process.c ../../kernel/process/scheduler.c ../../kernel/process/context.c ../../kernel/process/memory.c
test_process.c: In function â€˜printkâ€™:
test_process.c:12:5: warning: implicit declaration of function â€˜va_startâ€™ [-Wimplicit-function-declaration]
   12 |     va_start(args, fmt);
      |     ^~~~~~~~
test_process.c:14:5: warning: implicit declaration of function â€˜va_endâ€™ [-Wimplicit-function-declaration]
   14 |     va_end(args);
      |     ^~~~~~
test_process.c:12:5: warning: â€˜argsâ€™ is used uninitialized in this function [-Wuninitialized]
   12 |     va_start(args, fmt);
      |     ^~~~~~~~~~~~~~~~~~~
../../kernel/process/process.c: In function â€˜process_waitâ€™:
../../kernel/process/process.c:175:24: warning: unused parameter â€˜pidâ€™ [-Wunused-parameter]
  175 | int process_wait(pid_t pid, int *exit_code)
      |                  ~~~~~~^~~
../../kernel/process/process.c:175:34: warning: unused parameter â€˜exit_codeâ€™ [-Wunused-parameter]
  175 | int process_wait(pid_t pid, int *exit_code)
      |                             ~~~~~^~~~~~~~~
../../kernel/process/process.c: At top level:
../../kernel/process/process.c:180:1: warning: data definition has no type or storage class
  180 | EOF;
      | ^~~
../../kernel/process/process.c:180:1: warning: type defaults to â€˜intâ€™ in declaration of â€˜EOFâ€™ [-Wimplicit-int]
../../kernel/process/context.c: In function â€˜context_saveâ€™:
../../kernel/process/context.c:33:5: error: â€˜asmâ€™ operand has impossible constraints
   33 |     __asm__ volatile(
      |     ^~~~~~~
make: *** [Makefile:19ï¼štest_process] é”™è¯¯ 1
---
ä¿®æ”¹ä¸‹ï¼Œæˆ‘è¿™ä¸ªæ˜¯64ä½æ¶æ„çš„

---

_**Assistant**_



---



---

